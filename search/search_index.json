{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SimpleFormBuilder","text":""},{"location":"#pysimpleform","title":"PySimpleForm","text":"<p>PySimpleForm est une biblioth\u00e8que Python con\u00e7ue pour faciliter la cr\u00e9ation de notes de calcul techniques et physiques. Elle permet de d\u00e9finir des param\u00e8tres, des \u00e9quations et des v\u00e9rifications, puis de g\u00e9n\u00e9rer automatiquement un rapport format\u00e9 en LaTeX.</p> <p>Elle s'appuie sur des biblioth\u00e8ques robustes : - Pint pour la gestion rigoureuse des unit\u00e9s physiques. - SymPy pour le rendu symbolique des \u00e9quations. - NumPy pour les calculs num\u00e9riques et vectoriels.</p>"},{"location":"#fonctionnalites","title":"Fonctionnalit\u00e9s","text":"<ul> <li>D\u00e9finition de Param\u00e8tres : Stockage de constantes avec leurs unit\u00e9s et symboles LaTeX.</li> <li>\u00c9quations Symboliques : D\u00e9finition de formules sous forme de cha\u00eenes de caract\u00e8res (ex: <code>\"Fx / A\"</code>), \u00e9valu\u00e9es automatiquement.</li> <li>Conversion d'Unit\u00e9s : Conversion automatique des r\u00e9sultats dans l'unit\u00e9 souhait\u00e9e.</li> <li>V\u00e9rifications (Checks) : Tests logiques (ex: <code>sigma &lt;= sigma_adm</code>) avec retour visuel (OK/FAIL) dans le rapport.</li> <li>Rapport LaTeX : G\u00e9n\u00e9ration d'un code LaTeX pr\u00eat \u00e0 l'emploi (environnement <code>align*</code>) pour une int\u00e9gration facile dans des documents ou des notebooks (comme Marimo ou Jupyter).</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Le projet utilise <code>uv</code> pour la gestion des d\u00e9pendances. Assurez-vous d'avoir un environnement Python (&gt;= 3.13 recommand\u00e9) avec les d\u00e9pendances suivantes :</p> <ul> <li><code>pint</code></li> <li><code>sympy</code></li> <li><code>numpy</code></li> <li><code>marimo</code> (optionnel, pour l'affichage interactif)</li> </ul> <p>Si vous utilisez <code>uv</code> :</p> <pre><code>uv sync\n</code></pre> <p>Ou via pip :</p> <pre><code>pip install pint sympy numpy marimo\n</code></pre>"},{"location":"#exemple-dutilisation","title":"Exemple d'Utilisation","text":"<p>Voici comment utiliser <code>SimpleFormBuilder</code> pour cr\u00e9er une note de calcul simple (v\u00e9rification d'une contrainte).</p> <pre><code>from simpleformbuilder.builder import SimpleFormBuilder\n\n# 1. Initialisation\nbuilder = SimpleFormBuilder()\nu = builder.ureg  # Acc\u00e8s au registre d'unit\u00e9s de Pint\n\n# 2. D\u00e9finition des param\u00e8tres\n# add_param(nom_variable, symbole_latex, valeur, description)\nbuilder.add_param(\"Fx\", \"F_x\", 10 * u.kN, desc=\"Force axiale\")\nbuilder.add_param(\"A\", \"A\", 50 * u.cm**2, desc=\"Section transversale\")\nbuilder.add_param(\"sigma_adm\", r\"\\sigma_{adm}\", 100 * u.MPa, desc=\"Contrainte admissible\")\n\n# 3. D\u00e9finition des \u00e9quations\n# add_equation(nom_variable, symbole_latex, expression, unit\u00e9_cible, description)\nbuilder.add_equation(\n    \"sigma\", \n    r\"\\sigma\", \n    \"Fx / A\", \n    unit=u.MPa, \n    desc=\"Contrainte calcul\u00e9e\"\n)\n\n# 4. Ajout de v\u00e9rifications\n# add_check(expression_logique, description)\nbuilder.add_check(\"sigma &lt;= sigma_adm\", desc=\"V\u00e9rification de la contrainte\")\n\n# 5. Ex\u00e9cution des calculs\nbuilder.evaluate()\n\n# 6. G\u00e9n\u00e9ration du rapport\n# Le rapport est une cha\u00eene de caract\u00e8res contenant du code LaTeX\nreport = builder.report()\n\nprint(report)\n</code></pre>"},{"location":"#exemple-de-sortie-rendu","title":"Exemple de Sortie (Rendu)","text":"<p>Le rapport g\u00e9n\u00e9r\u00e9 ressemblera \u00e0 ceci une fois rendu (par exemple dans Marimo ou LaTeX) :</p> <p>$$ \\begin{align} F_x &amp;= 10.00\\ \\mathrm{kN} &amp;&amp; \\text{Force axiale} \\ A &amp;= 50.00\\ \\mathrm{cm}^2 &amp;&amp; \\text{Section transversale} \\ \\sigma_{adm} &amp;= 100.00\\ \\mathrm{MPa} &amp;&amp; \\text{Contrainte admissible} \\ \\sigma &amp;= \\frac{F_x}{A} = 2.00\\ \\mathrm{MPa} &amp;&amp; \\text{Contrainte calcul\u00e9e} \\ \\text{Check} &amp;: \\sigma \\leq \\sigma_{adm} \\rightarrow \\textbf{\\textcolor{green}{OK}} &amp;&amp; \\text{V\u00e9rification de la contrainte} \\ \\end{align} $$</p>"},{"location":"#utilisation-des-templates","title":"Utilisation des Templates","text":"<p><code>SimpleFormBuilder</code> supporte plusieurs styles de pr\u00e9sentation via le syst\u00e8me de templates.</p>"},{"location":"#templates-disponibles","title":"Templates disponibles","text":"<ul> <li><code>\"standard\"</code> (D\u00e9faut) : Pr\u00e9sentation tabulaire classique (<code>align*</code>).</li> <li><code>\"compact\"</code> : Pr\u00e9sentation simplifi\u00e9e sans descriptions textuelles (<code>align*</code>).</li> <li><code>\"detailed\"</code> : Pr\u00e9sentation sous forme de liste avec descriptions en gras (<code>itemize</code>).</li> </ul>"},{"location":"#exemple","title":"Exemple","text":"<pre><code># Initialisation avec un template\nbuilder = SimpleFormBuilder(template=\"detailed\")\n# ... ajout des param\u00e8tres et \u00e9quations ...\nprint(builder.report())\n</code></pre>"},{"location":"#personnalisation-de-lenvironnement","title":"Personnalisation de l'environnement","text":"<p>Vous pouvez forcer un environnement LaTeX sp\u00e9cifique (ex: <code>gather</code>, <code>equation</code>) lors de la g\u00e9n\u00e9ration, ce qui surcharge la configuration du template :</p> <pre><code>builder.report(environment=\"gather\")\n</code></pre>"},{"location":"#documentation-de-lapi","title":"Documentation de l'API","text":""},{"location":"#classe-simpleformbuilder","title":"Classe <code>SimpleFormBuilder</code>","text":""},{"location":"#add_paramname-symbol-value-desc-hiddenfalse-fmtnone","title":"<code>add_param(name, symbol, value, desc=\"\", hidden=False, fmt=None)</code>","text":"<p>Enregistre un param\u00e8tre constant. - <code>name</code> : Nom de la variable (identifiant Python valide). - <code>symbol</code> : Symbole LaTeX pour l'affichage. - <code>value</code> : Valeur (int, float, pint.Quantity ou np.ndarray). - <code>desc</code> : Description textuelle. - <code>fmt</code> : Formatage de la valeur (ex: <code>\".2f\"</code>, <code>\".1%\"</code>). Par d\u00e9faut <code>None</code> (utilise la pr\u00e9cision globale).</p>"},{"location":"#add_equationname-symbol-expr-unitnone-desc-hiddenfalse-fmtnone","title":"<code>add_equation(name, symbol, expr, unit=None, desc=\"\", hidden=False, fmt=None)</code>","text":"<p>Enregistre une \u00e9quation \u00e0 calculer. - <code>expr</code> : Expression math\u00e9matique sous forme de cha\u00eene (ex: <code>\"a * b + c\"</code>). - <code>unit</code> : Unit\u00e9 <code>pint</code> vers laquelle convertir le r\u00e9sultat. - <code>fmt</code> : Formatage du r\u00e9sultat (ex: <code>\".2f\"</code>). Par d\u00e9faut <code>None</code>.</p>"},{"location":"#add_checkexpr-desc-namecheck-fmtnone","title":"<code>add_check(expr, desc, name=\"Check\", fmt=None)</code>","text":"<p>Ajoute une \u00e9tape de validation. - <code>expr</code> : Expression bool\u00e9enne (ex: <code>\"x &gt; 0\"</code>). - <code>desc</code> : Description de la v\u00e9rification. - <code>fmt</code> : Formatage des valeurs affich\u00e9es dans l'expression (ex: <code>\".2f\"</code>).</p>"},{"location":"#evaluate","title":"<code>evaluate()</code>","text":"<p>Ex\u00e9cute tous les calculs et v\u00e9rifications dans l'ordre o\u00f9 ils ont \u00e9t\u00e9 ajout\u00e9s.</p>"},{"location":"#reportrow_templatesnone-environmentnone","title":"<code>report(row_templates=None, environment=None)</code>","text":"<p>G\u00e9n\u00e8re le code LaTeX du rapport. - <code>row_templates</code> : Dictionnaire optionnel pour personnaliser le formatage des lignes (<code>param</code>, <code>eq</code>, <code>check</code>). - <code>environment</code> : Environnement LaTeX optionnel (ex: <code>\"align*\"</code>, <code>\"itemize\"</code>). Si sp\u00e9cifi\u00e9, l'environnement choisi est forc\u00e9 pour toutes les sections du rapport, surchargeant la configuration du template choisi. Par d\u00e9faut (<code>None</code>), le rapport utilise les environnements d\u00e9finis par le template actif.</p>"},{"location":"#lambdify_equationname","title":"<code>lambdify_equation(name)</code>","text":"<p>G\u00e9n\u00e8re une fonction Python ex\u00e9cutable \u00e0 partir d'une \u00e9quation enregistr\u00e9e, optimis\u00e9e pour <code>pandas</code>. - <code>name</code> : Nom de l'\u00e9quation \u00e0 convertir. - Retourne : Une fonction qui accepte un DataFrame (ou dictionnaire) et retourne le r\u00e9sultat calcul\u00e9.     - Utilise les colonnes du DataFrame si elles correspondent aux variables de l'\u00e9quation (Priorit\u00e9 1 : Surcharge).     - Calcule r\u00e9cursivement les d\u00e9pendances interm\u00e9diaires si elles sont d\u00e9finies par d'autres \u00e9quations (Priorit\u00e9 2 : Calcul en cha\u00eene).     - Utilise les param\u00e8tres du <code>builder</code> pour les variables manquantes (Priorit\u00e9 3 : Constantes par d\u00e9faut).     - G\u00e8re automatiquement les unit\u00e9s <code>pint</code> et la vectorisation.</p> <p>Exemple d'utilisation avec Pandas :</p> <pre><code># Supposons une \u00e9quation \"sigma\" = \"Fx / A\" d\u00e9finie dans le builder\ncalc_sigma = builder.lambdify_equation(\"sigma\")\n\n# Cr\u00e9ation d'un DataFrame avec des valeurs variables pour Fx\nimport pandas as pd\ndf = pd.DataFrame({\n    'Fx': [10, 20, 30] * u.kN\n})\n\n# Ajout de la colonne calcul\u00e9e (A est pris dans les param\u00e8tres du builder)\ndf = df.assign(sigma_new = calc_sigma)\n</code></pre>"},{"location":"reference/","title":"Documentation du Code","text":"<p>Voici les fonctions disponibles dans mon projet.</p>"},{"location":"reference/#simpleformbuilder.builder.CalculationEngine","title":"<code>CalculationEngine</code>","text":"<p>Handles calculation execution and evaluation.</p> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>class CalculationEngine:\n    \"\"\"\n    Handles calculation execution and evaluation.\n    \"\"\"\n    def __init__(self, ureg: Optional[pint.UnitRegistry] = None):\n        self.ureg = ureg if ureg else pint.UnitRegistry()\n\n    def _evaluate_raw_expression(self, step: Dict[str, Any], graph: CalculationGraph, get_arg_value) -&gt; Any:\n        \"\"\"\n        Helper to compile (if needed) and evaluate a step's expression.\n        \"\"\"\n        if step[\"compiled_func\"] is None:\n                compiled_func, args_names = self._compile_equation(step[\"name\"], step[\"expr\"], graph)\n                step[\"compiled_func\"] = compiled_func\n                step[\"args_names\"] = args_names\n\n        compiled_func = step[\"compiled_func\"]\n        args_names = step[\"args_names\"]\n\n        args = [get_arg_value(arg) for arg in args_names]\n\n        return compiled_func(*args)\n\n    def evaluate(self, graph: CalculationGraph):\n        \"\"\"\n        Executes all registered calculations sequentially.\n        \"\"\"\n\n        # Helper to resolve arguments\n        def get_arg_value(arg_name):\n            if arg_name.startswith(\"UNIT_\"):\n                unit_name = arg_name[5:]\n                # Resolve unit\n                if hasattr(self.ureg, unit_name):\n                    return getattr(self.ureg, unit_name)\n                elif unit_name in self.ureg:\n                    return self.ureg[unit_name]\n                else:\n                    raise ValueError(f\"Unknown unit '{unit_name}' needed for calculation.\")\n            elif arg_name in graph.params:\n                return graph.params[arg_name]\n            else:\n                 raise KeyError(f\"Variable '{arg_name}' not found.\")\n\n        for step in graph.steps:\n            if step[\"type\"] == \"eq\":\n                try:\n                    # evaluation\n                    result = self._evaluate_raw_expression(step, graph, get_arg_value)\n\n                    # conversion d'unit\u00e9\n                    if step[\"unit\"]:\n                        if isinstance(result, pint.Quantity):\n                            result = result.to(step[\"unit\"])\n                        else:\n                             result = self.ureg.Quantity(result, step[\"unit\"])\n\n                    # stockage\n                    graph.params[step[\"name\"]] = result\n                    step[\"result\"] = result\n\n                except ZeroDivisionError:\n                    raise ZeroDivisionError(f\"Division by zero in equation '{step['name']}': {step['expr']}\")\n                except pint.DimensionalityError as e:\n                    raise pint.DimensionalityError(e.units1, e.units2, e.extra_msg) from e\n                except Exception as e:\n                    raise RuntimeError(f\"Error evaluating equation '{step['name']}': {e}\")\n\n            elif step[\"type\"] == \"check\":\n                try:\n                    # evaluation (bool\u00e9en)\n                    result = self._evaluate_raw_expression(step, graph, get_arg_value)\n\n                    # Handle numpy array results\n                    if isinstance(result, np.ndarray):\n                        step[\"result\"] = bool(result.all())\n                    else:\n                        step[\"result\"] = bool(result)\n                except Exception as e:\n                     raise RuntimeError(f\"Error evaluating check '{step['desc']}': {e}\")\n\n\n    def lambdify_equation(self, graph: CalculationGraph, name: str) -&gt; Any:\n        \"\"\"\n        Creates a function from the specified equation compatible with pandas.DataFrame.assign.\n\n        Mechanisms:\n        1. **Variable Resolution Priority**:\n           - **DataFrame/Input Dict**: Variables present in the input `df` (columns or keys) are used first.\n           - **Computed Dependencies**: If a variable is an equation in the graph, it is recursively calculated (unless overridden by `df`).\n           - **Parameters**: If a variable is a constant parameter (root input), it is taken from `SimpleFormBuilder.params`.\n           - **Error**: If missing in all sources, a `KeyError` is raised.\n\n        2. **Unit Injection**:\n           - If a variable comes from `df` but also exists in `params` as a `pint.Quantity`, the corresponding unit is automatically injected (multiplied) into the values from `df`. This ensures unit consistency within the expression.\n\n        3. **Unit Output**:\n           - If the equation has a target `unit` defined, the result is converted to that unit before being returned.\n\n        Args:\n            graph (CalculationGraph): The calculation graph containing equations and parameters.\n            name (str): The name of the equation to lambdify.\n\n        Returns:\n            Callable[[DataFrame | dict], Series | np.ndarray]: A function that accepts a DataFrame or dict and returns the calculated result.\n\n        Raises:\n            KeyError: If the equation is not found.\n        \"\"\"\n        # Find the equation step\n        eq_step = None\n        for step in graph.steps:\n            if step.get(\"type\") == \"eq\" and step.get(\"name\") == name:\n                eq_step = step\n                break\n\n        if not eq_step:\n            raise KeyError(f\"Equation '{name}' not found.\")\n\n        # Compile WITHOUT expansion to preserve intermediate variables in signature\n        compiled_func, args_names = self._compile_equation(name, eq_step[\"expr\"], graph, expand=False)\n\n        target_unit = eq_step.get(\"unit\")\n\n        # Pre-compile dependency functions for any arguments that are themselves equations\n        dep_funcs = {}\n        for arg in args_names:\n            # Check if arg corresponds to an equation step\n            step = next((s for s in graph.steps if s.get(\"name\") == arg), None)\n            if step and step.get(\"type\") == \"eq\":\n                # Recursively create lambda for the dependency\n                dep_funcs[arg] = self.lambdify_equation(graph, arg)\n\n        def wrapper(df):\n            # df can be DataFrame or dict-like\n            args = []\n            for arg_name in args_names:\n                # 1. Handle unit constants injected by _compile_equation (e.g. UNIT_meter)\n                if arg_name.startswith(\"UNIT_\"):\n                    unit_name = arg_name[5:]\n                    if hasattr(self.ureg, unit_name):\n                        val = getattr(self.ureg, unit_name)\n                    elif unit_name in self.ureg:\n                         val = self.ureg[unit_name]\n                    else:\n                         raise ValueError(f\"Unknown unit '{unit_name}' in equation.\")\n                    args.append(val)\n                    continue\n\n                # 2. Handle DataFrame/Dict input (Highest Priority Override)\n                if arg_name in df:\n                    val = df[arg_name]\n\n                    # Convert to numpy/values if possible\n                    if hasattr(val, \"values\"):\n                        val = val.values\n                    elif isinstance(val, (list, tuple)):\n                        val = np.array(val)\n\n                    # Inject Units from params if applicable\n                    # If the variable exists in params with a unit, we multiply the raw dataframe values by that unit.\n                    if arg_name in graph.params:\n                        default_val = graph.params[arg_name]\n                        if isinstance(default_val, pint.Quantity):\n                             # Only apply unit if val is NOT already a Quantity\n                             if not isinstance(val, pint.Quantity):\n                                val = val * default_val.units\n\n                    args.append(val)\n\n                # 3. Handle Computed Dependencies (Dynamic Calculation)\n                elif arg_name in dep_funcs:\n                    # Recursive call with the same dataframe to compute the missing intermediate\n                    val = dep_funcs[arg_name](df)\n                    args.append(val)\n\n                # 4. Handle constant from params (Fallback)\n                elif arg_name in graph.params:\n                    args.append(graph.params[arg_name])\n\n                else:\n                    raise KeyError(f\"Variable '{arg_name}' required for equation '{name}' not found in DataFrame, Dependencies, or Builder parameters.\")\n\n            # Calculate\n            res = compiled_func(*args)\n\n            # 5. Convert to target unit\n            if target_unit:\n                if isinstance(res, pint.Quantity):\n                    res = res.to(target_unit)\n                # Note: if res is not a Quantity (concerns about unit validation failure?), we might skip.\n                # But typically it should be if inputs had units.\n            else:\n                if hasattr(res, \"dimensionless\") and res.dimensionless:\n                    if isinstance(res, pint.Quantity):\n                        res = res.to(\"dimensionless\")\n                    res = res.magnitude\n\n            return res\n\n        return wrapper\n\n    def _compile_equation(self, name: str, expr: str, graph: CalculationGraph, expand: bool = False):\n        \"\"\"\n        Compiles an equation expression using SymPy and lambdify.\n\n        Args:\n            name: Equation name.\n            expr: Mathematical expression string.\n            graph: CalculationGraph instance.\n            expand: If True, recursively substitutes dependencies that are other equations.\n        \"\"\"\n        try:\n            # D\u00e9finir le contexte autoris\u00e9 pour le parsing\n            allowed_locals = ALLOWED_LOCALS.copy()\n\n            valid_symbols = set(graph.params.keys())\n            for step_item in graph.steps:\n                if step_item.get(\"name\"):\n                    valid_symbols.add(step_item[\"name\"])\n\n            # Helper for unit replacement (u.meter -&gt; UNIT_meter)\n            def process_expression_string(raw_expr):\n                def unit_replacer(match):\n                    unit_name = match.group(1)\n                    # We could check existence, but simpler to just map\n                    return f\"UNIT_{unit_name}\"\n\n                proc_expr = re.sub(r\"\\bu\\.([a-zA-Z_]\\w*)\", unit_replacer, raw_expr)\n\n                # Update allowed_locals with found units\n                used_units = re.findall(r\"UNIT_([a-zA-Z_]\\w*)\", proc_expr)\n                for u_name in used_units:\n                    sym_name = f\"UNIT_{u_name}\"\n                    if sym_name not in allowed_locals:\n                        allowed_locals[sym_name] = sympy.Symbol(sym_name)\n\n                return proc_expr\n\n            expr_processed = process_expression_string(expr)\n\n            for sym_name in valid_symbols:\n                allowed_locals[sym_name] = sympy.Symbol(sym_name)\n\n            # Parsing s\u00e9curis\u00e9 de l'expression initiale\n            sym_expr = sympy.sympify(expr_processed, locals=allowed_locals)\n\n            if expand:\n                # Recursive substitution of intermediate equations\n                max_depth = 20\n                current_depth = 0\n\n                while current_depth &lt; max_depth:\n                    free_syms = sym_expr.free_symbols\n                    subs_dict = {}\n                    performed_sub = False\n\n                    for sym in free_syms:\n                        sym_str = str(sym)\n                        # Check if this symbol matches an existing Equation in the graph\n                        # We should skip if it's a Parameter (leaf)\n                        step = next((s for s in graph.steps if s.get(\"name\") == sym_str), None)\n\n                        if step and step[\"type\"] == \"eq\":\n                            # Found an intermediate equation defined in the graph\n                            sub_expr_str = step[\"expr\"]\n\n                            # Process units in the sub-expression\n                            sub_expr_processed = process_expression_string(sub_expr_str)\n\n                            # Sympify\n                            sub_sym_expr = sympy.sympify(sub_expr_processed, locals=allowed_locals)\n\n                            subs_dict[sym] = sub_sym_expr\n                            performed_sub = True\n\n                    if not performed_sub:\n                        break\n\n                    sym_expr = sym_expr.subs(subs_dict)\n                    current_depth += 1\n\n                if current_depth == max_depth:\n                     raise RecursionError(f\"Max recursion depth reached while expanding equation '{name}'. Possible cycle.\")\n\n            # Compilation avec lambdify\n            args_syms = sorted(list(sym_expr.free_symbols), key=lambda s: str(s))\n            args_names = [str(s) for s in args_syms]\n\n            compiled_func = sympy.lambdify(args_syms, sym_expr, modules=[\"numpy\", \"math\"])\n            return compiled_func, args_names\n\n        except Exception as e:\n            raise ValueError(f\"Invalid or unsafe expression '{expr}' for '{name}': {e}\")\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.CalculationEngine.evaluate","title":"<code>evaluate(graph)</code>","text":"<p>Executes all registered calculations sequentially.</p> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>def evaluate(self, graph: CalculationGraph):\n    \"\"\"\n    Executes all registered calculations sequentially.\n    \"\"\"\n\n    # Helper to resolve arguments\n    def get_arg_value(arg_name):\n        if arg_name.startswith(\"UNIT_\"):\n            unit_name = arg_name[5:]\n            # Resolve unit\n            if hasattr(self.ureg, unit_name):\n                return getattr(self.ureg, unit_name)\n            elif unit_name in self.ureg:\n                return self.ureg[unit_name]\n            else:\n                raise ValueError(f\"Unknown unit '{unit_name}' needed for calculation.\")\n        elif arg_name in graph.params:\n            return graph.params[arg_name]\n        else:\n             raise KeyError(f\"Variable '{arg_name}' not found.\")\n\n    for step in graph.steps:\n        if step[\"type\"] == \"eq\":\n            try:\n                # evaluation\n                result = self._evaluate_raw_expression(step, graph, get_arg_value)\n\n                # conversion d'unit\u00e9\n                if step[\"unit\"]:\n                    if isinstance(result, pint.Quantity):\n                        result = result.to(step[\"unit\"])\n                    else:\n                         result = self.ureg.Quantity(result, step[\"unit\"])\n\n                # stockage\n                graph.params[step[\"name\"]] = result\n                step[\"result\"] = result\n\n            except ZeroDivisionError:\n                raise ZeroDivisionError(f\"Division by zero in equation '{step['name']}': {step['expr']}\")\n            except pint.DimensionalityError as e:\n                raise pint.DimensionalityError(e.units1, e.units2, e.extra_msg) from e\n            except Exception as e:\n                raise RuntimeError(f\"Error evaluating equation '{step['name']}': {e}\")\n\n        elif step[\"type\"] == \"check\":\n            try:\n                # evaluation (bool\u00e9en)\n                result = self._evaluate_raw_expression(step, graph, get_arg_value)\n\n                # Handle numpy array results\n                if isinstance(result, np.ndarray):\n                    step[\"result\"] = bool(result.all())\n                else:\n                    step[\"result\"] = bool(result)\n            except Exception as e:\n                 raise RuntimeError(f\"Error evaluating check '{step['desc']}': {e}\")\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.CalculationEngine.lambdify_equation","title":"<code>lambdify_equation(graph, name)</code>","text":"<p>Creates a function from the specified equation compatible with pandas.DataFrame.assign.</p> <p>Mechanisms: 1. Variable Resolution Priority:    - DataFrame/Input Dict: Variables present in the input <code>df</code> (columns or keys) are used first.    - Computed Dependencies: If a variable is an equation in the graph, it is recursively calculated (unless overridden by <code>df</code>).    - Parameters: If a variable is a constant parameter (root input), it is taken from <code>SimpleFormBuilder.params</code>.    - Error: If missing in all sources, a <code>KeyError</code> is raised.</p> <ol> <li>Unit Injection:</li> <li> <p>If a variable comes from <code>df</code> but also exists in <code>params</code> as a <code>pint.Quantity</code>, the corresponding unit is automatically injected (multiplied) into the values from <code>df</code>. This ensures unit consistency within the expression.</p> </li> <li> <p>Unit Output:</p> </li> <li>If the equation has a target <code>unit</code> defined, the result is converted to that unit before being returned.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>CalculationGraph</code> <p>The calculation graph containing equations and parameters.</p> required <code>name</code> <code>str</code> <p>The name of the equation to lambdify.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Callable[[DataFrame | dict], Series | np.ndarray]: A function that accepts a DataFrame or dict and returns the calculated result.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the equation is not found.</p> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>def lambdify_equation(self, graph: CalculationGraph, name: str) -&gt; Any:\n    \"\"\"\n    Creates a function from the specified equation compatible with pandas.DataFrame.assign.\n\n    Mechanisms:\n    1. **Variable Resolution Priority**:\n       - **DataFrame/Input Dict**: Variables present in the input `df` (columns or keys) are used first.\n       - **Computed Dependencies**: If a variable is an equation in the graph, it is recursively calculated (unless overridden by `df`).\n       - **Parameters**: If a variable is a constant parameter (root input), it is taken from `SimpleFormBuilder.params`.\n       - **Error**: If missing in all sources, a `KeyError` is raised.\n\n    2. **Unit Injection**:\n       - If a variable comes from `df` but also exists in `params` as a `pint.Quantity`, the corresponding unit is automatically injected (multiplied) into the values from `df`. This ensures unit consistency within the expression.\n\n    3. **Unit Output**:\n       - If the equation has a target `unit` defined, the result is converted to that unit before being returned.\n\n    Args:\n        graph (CalculationGraph): The calculation graph containing equations and parameters.\n        name (str): The name of the equation to lambdify.\n\n    Returns:\n        Callable[[DataFrame | dict], Series | np.ndarray]: A function that accepts a DataFrame or dict and returns the calculated result.\n\n    Raises:\n        KeyError: If the equation is not found.\n    \"\"\"\n    # Find the equation step\n    eq_step = None\n    for step in graph.steps:\n        if step.get(\"type\") == \"eq\" and step.get(\"name\") == name:\n            eq_step = step\n            break\n\n    if not eq_step:\n        raise KeyError(f\"Equation '{name}' not found.\")\n\n    # Compile WITHOUT expansion to preserve intermediate variables in signature\n    compiled_func, args_names = self._compile_equation(name, eq_step[\"expr\"], graph, expand=False)\n\n    target_unit = eq_step.get(\"unit\")\n\n    # Pre-compile dependency functions for any arguments that are themselves equations\n    dep_funcs = {}\n    for arg in args_names:\n        # Check if arg corresponds to an equation step\n        step = next((s for s in graph.steps if s.get(\"name\") == arg), None)\n        if step and step.get(\"type\") == \"eq\":\n            # Recursively create lambda for the dependency\n            dep_funcs[arg] = self.lambdify_equation(graph, arg)\n\n    def wrapper(df):\n        # df can be DataFrame or dict-like\n        args = []\n        for arg_name in args_names:\n            # 1. Handle unit constants injected by _compile_equation (e.g. UNIT_meter)\n            if arg_name.startswith(\"UNIT_\"):\n                unit_name = arg_name[5:]\n                if hasattr(self.ureg, unit_name):\n                    val = getattr(self.ureg, unit_name)\n                elif unit_name in self.ureg:\n                     val = self.ureg[unit_name]\n                else:\n                     raise ValueError(f\"Unknown unit '{unit_name}' in equation.\")\n                args.append(val)\n                continue\n\n            # 2. Handle DataFrame/Dict input (Highest Priority Override)\n            if arg_name in df:\n                val = df[arg_name]\n\n                # Convert to numpy/values if possible\n                if hasattr(val, \"values\"):\n                    val = val.values\n                elif isinstance(val, (list, tuple)):\n                    val = np.array(val)\n\n                # Inject Units from params if applicable\n                # If the variable exists in params with a unit, we multiply the raw dataframe values by that unit.\n                if arg_name in graph.params:\n                    default_val = graph.params[arg_name]\n                    if isinstance(default_val, pint.Quantity):\n                         # Only apply unit if val is NOT already a Quantity\n                         if not isinstance(val, pint.Quantity):\n                            val = val * default_val.units\n\n                args.append(val)\n\n            # 3. Handle Computed Dependencies (Dynamic Calculation)\n            elif arg_name in dep_funcs:\n                # Recursive call with the same dataframe to compute the missing intermediate\n                val = dep_funcs[arg_name](df)\n                args.append(val)\n\n            # 4. Handle constant from params (Fallback)\n            elif arg_name in graph.params:\n                args.append(graph.params[arg_name])\n\n            else:\n                raise KeyError(f\"Variable '{arg_name}' required for equation '{name}' not found in DataFrame, Dependencies, or Builder parameters.\")\n\n        # Calculate\n        res = compiled_func(*args)\n\n        # 5. Convert to target unit\n        if target_unit:\n            if isinstance(res, pint.Quantity):\n                res = res.to(target_unit)\n            # Note: if res is not a Quantity (concerns about unit validation failure?), we might skip.\n            # But typically it should be if inputs had units.\n        else:\n            if hasattr(res, \"dimensionless\") and res.dimensionless:\n                if isinstance(res, pint.Quantity):\n                    res = res.to(\"dimensionless\")\n                res = res.magnitude\n\n        return res\n\n    return wrapper\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.CalculationGraph","title":"<code>CalculationGraph</code>","text":"<p>Manages the structure of parameters, equations, and checks.</p> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>class CalculationGraph:\n    \"\"\"\n    Manages the structure of parameters, equations, and checks.\n    \"\"\"\n    def __init__(self):\n        self.params: Dict[str, Any] = {}\n        self.symbols: Dict[str, str] = {}\n        self.steps: List[Dict[str, Any]] = []\n\n    def _validate_expression(self, name: str, expr: str):\n        \"\"\"\n        Validates the mathematical expression for security and correctness.\n\n        Args:\n            name (str): The name associated with the expression.\n            expr (str): The mathematical expression to validate.\n\n        Raises:\n            ValueError: If the name is invalid, the expression contains forbidden patterns,\n                or uses undefined variables/functions.\n        \"\"\"\n        # Validate name\n        if not name.isidentifier():\n             raise ValueError(f\"Name '{name}' must be a valid Python identifier.\")\n\n        # Security check\n        try:\n            security_check(name, expr)\n        except ValueError as e:\n            raise ValueError(f\"Invalid expression for '{name}': {e}\")\n\n        # Note: Further AST/Symbolic validation could be added here if needed,\n        # checking against self.params and self.symbols.\n\n\n    def add_param(self, name: str, symbol: str, value: Any, desc: str = \"\", hidden: bool = False, fmt: str = None):\n        \"\"\"\n        Registers a constant parameter in the calculation graph.\n\n        Args:\n            name (str): Unique identifier for the parameter (must be a valid Python identifier).\n            symbol (str): LaTeX representation of the parameter symbol (e.g., \"\\\\sigma\").\n            value (int, float, pint.Quantity, np.ndarray): The numerical value or physical quantity.\n            desc (str, optional): A description of the parameter. Defaults to \"\".\n            hidden (bool, optional): If True, the parameter will not appear in the generated report. Defaults to False.\n            fmt (str, optional): Format string for displaying the value (e.g., \".2f\"). Defaults to None.\n\n        Raises:\n            ValueError: If `name` is not a valid Python identifier.\n            TypeError: If `value` is not one of the accepted types (int, float, pint.Quantity, np.ndarray).\n        \"\"\"\n        # Name validation\n        if not name.isidentifier():\n            raise ValueError(f\"Parameter name '{name}' must be a valid Python identifier.\")\n\n        # Type validation\n        if not isinstance(value, (int, float, pint.Quantity, np.ndarray)):\n             raise TypeError(f\"Value for '{name}' must be an int, float, pint.Quantity, or np.ndarray. Got {type(value)}.\")\n\n        self.params[name] = value\n        self.symbols[name] = symbol\n\n        self.steps.append({\n            \"type\": \"param\",\n            \"name\": name,\n            \"symbol\": symbol,\n            \"value\": value,\n            \"desc\": desc,\n            \"hidden\": hidden,\n            \"fmt\": fmt\n        })\n\n    def add_equation(self, name: str, symbol: str, expr: str, unit: Any = None, desc: str = \"\", hidden: bool = False, fmt: str = None):\n        \"\"\"\n        Registers an equation to be calculated.\n\n        Args:\n            name (str): Unique identifier for the result variable.\n            symbol (str): LaTeX representation of the result symbol.\n            expr (str): The mathematical expression as a string.\n            unit (Any, optional): The expected unit of the result. If provided, the result will be converted to this unit. Defaults to None.\n            desc (str, optional): Description of the equation. Defaults to \"\".\n            hidden (bool, optional): If True, this step will be hidden in the report. Defaults to False.\n            fmt (str, optional): Format string for the result. Defaults to None.\n\n        Raises:\n            ValueError: If `name` is invalid or `expr` contains forbidden content.\n        \"\"\"\n        # Validation\n        self._validate_expression(name, expr)\n\n        self.symbols[name] = symbol\n\n        # Validation of cycles could be done here (optional placeholder)\n        # Note: cycles are not checked for now assumed to be handled by the user\n        # self.validate_graph(current_node=name, dependencies=self._extract_deps(expr))\n\n        self.steps.append({\n            \"type\": \"eq\",\n            \"name\": name,\n            \"symbol\": symbol,\n            \"expr\": expr,\n            \"unit\": unit,\n            \"desc\": desc,\n            \"hidden\": hidden,\n            \"fmt\": fmt,\n            \"compiled_func\": None, # Delayed compilation\n            \"args_names\": []\n        })\n\n    def add_check(self, expr: str, desc: str, name: str = \"Check\", fmt: str = None):\n        \"\"\"\n        Registers a check/validation step (boolean expression).\n\n        Args:\n            expr (str): The boolean expression to evaluate (e.g. \"x &gt; 0\").\n            desc (str): Description of what is being checked.\n            name (str, optional): Identifier for the check. Defaults to \"Check\".\n            fmt (str, optional): Format string for values displayed in the check expression. Defaults to None.\n\n        Raises:\n            ValueError: If `expr` is invalid or unsafe.\n        \"\"\"\n        # Validation\n        self._validate_expression(name, expr)\n\n        # Validation of cycles (optional placeholder)\n        # self.validate_graph(current_node=name, dependencies=self._extract_deps(expr))\n\n        self.steps.append({\n            \"type\": \"check\",\n            \"name\": name,\n            \"expr\": expr,\n            \"desc\": desc,\n            \"fmt\": fmt,\n            \"compiled_func\": None, # Delayed compilation\n            \"args_names\": []\n        })\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.CalculationGraph.add_check","title":"<code>add_check(expr, desc, name='Check', fmt=None)</code>","text":"<p>Registers a check/validation step (boolean expression).</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The boolean expression to evaluate (e.g. \"x &gt; 0\").</p> required <code>desc</code> <code>str</code> <p>Description of what is being checked.</p> required <code>name</code> <code>str</code> <p>Identifier for the check. Defaults to \"Check\".</p> <code>'Check'</code> <code>fmt</code> <code>str</code> <p>Format string for values displayed in the check expression. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>expr</code> is invalid or unsafe.</p> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>def add_check(self, expr: str, desc: str, name: str = \"Check\", fmt: str = None):\n    \"\"\"\n    Registers a check/validation step (boolean expression).\n\n    Args:\n        expr (str): The boolean expression to evaluate (e.g. \"x &gt; 0\").\n        desc (str): Description of what is being checked.\n        name (str, optional): Identifier for the check. Defaults to \"Check\".\n        fmt (str, optional): Format string for values displayed in the check expression. Defaults to None.\n\n    Raises:\n        ValueError: If `expr` is invalid or unsafe.\n    \"\"\"\n    # Validation\n    self._validate_expression(name, expr)\n\n    # Validation of cycles (optional placeholder)\n    # self.validate_graph(current_node=name, dependencies=self._extract_deps(expr))\n\n    self.steps.append({\n        \"type\": \"check\",\n        \"name\": name,\n        \"expr\": expr,\n        \"desc\": desc,\n        \"fmt\": fmt,\n        \"compiled_func\": None, # Delayed compilation\n        \"args_names\": []\n    })\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.CalculationGraph.add_equation","title":"<code>add_equation(name, symbol, expr, unit=None, desc='', hidden=False, fmt=None)</code>","text":"<p>Registers an equation to be calculated.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the result variable.</p> required <code>symbol</code> <code>str</code> <p>LaTeX representation of the result symbol.</p> required <code>expr</code> <code>str</code> <p>The mathematical expression as a string.</p> required <code>unit</code> <code>Any</code> <p>The expected unit of the result. If provided, the result will be converted to this unit. Defaults to None.</p> <code>None</code> <code>desc</code> <code>str</code> <p>Description of the equation. Defaults to \"\".</p> <code>''</code> <code>hidden</code> <code>bool</code> <p>If True, this step will be hidden in the report. Defaults to False.</p> <code>False</code> <code>fmt</code> <code>str</code> <p>Format string for the result. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>name</code> is invalid or <code>expr</code> contains forbidden content.</p> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>def add_equation(self, name: str, symbol: str, expr: str, unit: Any = None, desc: str = \"\", hidden: bool = False, fmt: str = None):\n    \"\"\"\n    Registers an equation to be calculated.\n\n    Args:\n        name (str): Unique identifier for the result variable.\n        symbol (str): LaTeX representation of the result symbol.\n        expr (str): The mathematical expression as a string.\n        unit (Any, optional): The expected unit of the result. If provided, the result will be converted to this unit. Defaults to None.\n        desc (str, optional): Description of the equation. Defaults to \"\".\n        hidden (bool, optional): If True, this step will be hidden in the report. Defaults to False.\n        fmt (str, optional): Format string for the result. Defaults to None.\n\n    Raises:\n        ValueError: If `name` is invalid or `expr` contains forbidden content.\n    \"\"\"\n    # Validation\n    self._validate_expression(name, expr)\n\n    self.symbols[name] = symbol\n\n    # Validation of cycles could be done here (optional placeholder)\n    # Note: cycles are not checked for now assumed to be handled by the user\n    # self.validate_graph(current_node=name, dependencies=self._extract_deps(expr))\n\n    self.steps.append({\n        \"type\": \"eq\",\n        \"name\": name,\n        \"symbol\": symbol,\n        \"expr\": expr,\n        \"unit\": unit,\n        \"desc\": desc,\n        \"hidden\": hidden,\n        \"fmt\": fmt,\n        \"compiled_func\": None, # Delayed compilation\n        \"args_names\": []\n    })\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.CalculationGraph.add_param","title":"<code>add_param(name, symbol, value, desc='', hidden=False, fmt=None)</code>","text":"<p>Registers a constant parameter in the calculation graph.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the parameter (must be a valid Python identifier).</p> required <code>symbol</code> <code>str</code> <p>LaTeX representation of the parameter symbol (e.g., \"\\sigma\").</p> required <code>value</code> <code>(int, float, Quantity, ndarray)</code> <p>The numerical value or physical quantity.</p> required <code>desc</code> <code>str</code> <p>A description of the parameter. Defaults to \"\".</p> <code>''</code> <code>hidden</code> <code>bool</code> <p>If True, the parameter will not appear in the generated report. Defaults to False.</p> <code>False</code> <code>fmt</code> <code>str</code> <p>Format string for displaying the value (e.g., \".2f\"). Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>name</code> is not a valid Python identifier.</p> <code>TypeError</code> <p>If <code>value</code> is not one of the accepted types (int, float, pint.Quantity, np.ndarray).</p> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>def add_param(self, name: str, symbol: str, value: Any, desc: str = \"\", hidden: bool = False, fmt: str = None):\n    \"\"\"\n    Registers a constant parameter in the calculation graph.\n\n    Args:\n        name (str): Unique identifier for the parameter (must be a valid Python identifier).\n        symbol (str): LaTeX representation of the parameter symbol (e.g., \"\\\\sigma\").\n        value (int, float, pint.Quantity, np.ndarray): The numerical value or physical quantity.\n        desc (str, optional): A description of the parameter. Defaults to \"\".\n        hidden (bool, optional): If True, the parameter will not appear in the generated report. Defaults to False.\n        fmt (str, optional): Format string for displaying the value (e.g., \".2f\"). Defaults to None.\n\n    Raises:\n        ValueError: If `name` is not a valid Python identifier.\n        TypeError: If `value` is not one of the accepted types (int, float, pint.Quantity, np.ndarray).\n    \"\"\"\n    # Name validation\n    if not name.isidentifier():\n        raise ValueError(f\"Parameter name '{name}' must be a valid Python identifier.\")\n\n    # Type validation\n    if not isinstance(value, (int, float, pint.Quantity, np.ndarray)):\n         raise TypeError(f\"Value for '{name}' must be an int, float, pint.Quantity, or np.ndarray. Got {type(value)}.\")\n\n    self.params[name] = value\n    self.symbols[name] = symbol\n\n    self.steps.append({\n        \"type\": \"param\",\n        \"name\": name,\n        \"symbol\": symbol,\n        \"value\": value,\n        \"desc\": desc,\n        \"hidden\": hidden,\n        \"fmt\": fmt\n    })\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.LaTeXFormatter","title":"<code>LaTeXFormatter</code>","text":"<p>Dedicated format and generation of the LaTeX report.</p> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>class LaTeXFormatter:\n    \"\"\"\n    Dedicated format and generation of the LaTeX report.\n    \"\"\"\n    def __init__(self, precision: int = 2, template: Any = \"standard\"):\n        self.precision = precision\n        self.template = LaTeXTemplateLibrary.get_template(template)\n\n    def _format_value(self, val: Any, fmt_spec: Optional[str] = None) -&gt; str:\n        \"\"\"Helper to format a value using the specified precision/format.\"\"\"\n        if fmt_spec:\n            f_str = f\"{{:{fmt_spec}}}\"\n        else:\n            f_str = f\"{{:.{self.precision}f}}\"\n\n        if isinstance(val, pint.Quantity):\n            mag = val.magnitude\n            if isinstance(mag, np.ndarray):\n                # Array formatting\n                mag_str = r'\\begin{bmatrix}' + np.array2string(\n                    mag, \n                    precision=self.precision, \n                    separator=r'\\\\', \n                    formatter={'float_kind' : lambda x : f_str.format(x)}\n                ).strip(\"[]\") + r'\\end{bmatrix}'\n            else:\n                # Scalar formatting\n                mag_str = f_str.format(mag)\n\n            unit_str = rf\"\\ {val.units:~L}\"\n            return f\"{mag_str}{unit_str}\".replace(\"%\", r\"\\%\")\n\n        elif isinstance(val, (int, float)):\n            return f_str.format(val).replace(\"%\", r\"\\%\")\n\n        elif isinstance(val, np.ndarray):\n            return np.array2string(\n                val, \n                precision=self.precision, \n                separator=', ', \n                formatter={'float_kind' : lambda x : f_str.format(x)}\n            )\n        else:\n            return str(val)\n\n    def _format_expr(self, expr_str: str, graph: CalculationGraph) -&gt; str:\n        \"\"\"Helper to format an expression string to LaTeX.\"\"\"\n        try:\n            local_dict = {name: sympy.Symbol(name) for name in graph.params.keys()}\n            sym_expr = sympy.sympify(expr_str, locals=local_dict, evaluate=False)\n            symbol_names = {sympy.Symbol(name): sym for name, sym in graph.symbols.items()}\n            return sympy.latex(sym_expr, symbol_names=symbol_names)\n        except Exception:\n            return expr_str.replace(\"**\", \"^\").replace(\"*\", r\"\\cdot \")\n\n    def report(self, graph: CalculationGraph, row_templates: Optional[Dict[str, str]] = None, environment: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Generates the LaTeX report.\n\n        Args:\n            graph: The calculation graph.\n            row_templates: Optional overrides for specific row types.\n            environment: Optional override for the environment. If provided (not None), it overrides the template's environment settings for ALL steps.\n        \"\"\"\n        # 1. Resolve effective template configuration\n        current_template = self.template.copy()\n\n        # Merge row_templates if provided\n        if row_templates:\n            current_template[\"rows\"] = current_template.get(\"rows\", {}).copy()\n            current_template[\"rows\"].update(row_templates)\n\n        rows_config = current_template.get(\"rows\", {})\n        envs_config = current_template.get(\"environments\", {})\n\n        lines = []\n        current_env = None\n\n        for step in graph.steps:\n            if step.get(\"hidden\", False):\n                continue\n\n            step_type = step[\"type\"]\n\n            # Determine required environment\n            # Priority: \n            # 1. `environment` argument (if explicit override provided)\n            # 2. Template `environments` config for this type\n            # 3. Default \"align*\"\n\n            if environment is not None:\n                req_env = environment\n            else:\n                req_env = envs_config.get(step_type, \"align*\")\n\n            # Environment switching\n            if current_env != req_env:\n                if current_env is not None:\n                    lines.append(f\"\\\\end{{{current_env}}}\")\n\n                if req_env is not None:\n                    lines.append(f\"\\\\begin{{{req_env}}}\")\n\n                current_env = req_env\n\n            # Prepare data for template\n            data = {\n                \"symbol\": step.get(\"symbol\", \"\"),\n                \"name\": step.get(\"name\", \"\"),\n                \"desc\": step.get(\"desc\", \"\"),\n                \"value\": \"\",\n                \"expr\": \"\",\n                \"status\": \"\"\n            }\n\n            if step_type == \"param\":\n                data[\"value\"] = self._format_value(step[\"value\"], step.get(\"fmt\"))\n\n            elif step_type == \"eq\":\n                data[\"value\"] = self._format_value(step.get(\"result\"), step.get(\"fmt\"))\n                data[\"expr\"] = self._format_expr(step[\"expr\"], graph)\n\n            elif step_type == \"check\":\n                data[\"status\"] = r\"\\textbf{\\textcolor{green}{OK}}\" if step.get(\"result\") else r\"\\textbf{\\textcolor{red}{NOK}}\"\n                try:\n                    local_dict = {name: sympy.Symbol(name) for name in graph.params.keys()}\n                    sym_expr = sympy.sympify(step[\"expr\"], locals=local_dict, evaluate=False)\n                    if not step.get(\"result\"):\n                        sym_expr = sympy.Not(sym_expr)\n                    subs = {}\n                    for sym in sym_expr.free_symbols:\n                        sym_name = str(sym)\n                        if sym_name in graph.params:\n                            val = graph.params[sym_name]\n                            latex_sym = graph.symbols.get(sym_name, sym_name)\n                            fmt = step.get(\"fmt\")\n                            if fmt is None:\n                                for s in graph.steps:\n                                    if s.get(\"name\") == sym_name:\n                                        fmt = s.get(\"fmt\")\n                                        break\n                            val_str = self._format_value(val, fmt)\n                            # Simple substitution for logic display\n                            new_sym_latex = rf\"{{{latex_sym}}} = {val_str}\"\n                            subs[sym] = sympy.Symbol(new_sym_latex)\n                    data[\"expr\"] = sympy.latex(sym_expr.subs(subs))\n                except Exception:\n                    data[\"expr\"] = self._format_expr(step[\"expr\"], graph)\n\n            # Render row\n            try:\n                row_tpl = rows_config.get(step_type, \"\")\n                line = row_tpl.format(**data)\n                lines.append(line)\n            except Exception as e:\n                lines.append(f\"% Error rendering step {step.get('name')}: {e}\")\n\n        # Close final environment\n        if current_env is not None:\n            lines.append(f\"\\\\end{{{current_env}}}\")\n\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.LaTeXFormatter.report","title":"<code>report(graph, row_templates=None, environment=None)</code>","text":"<p>Generates the LaTeX report.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>CalculationGraph</code> <p>The calculation graph.</p> required <code>row_templates</code> <code>Optional[Dict[str, str]]</code> <p>Optional overrides for specific row types.</p> <code>None</code> <code>environment</code> <code>Optional[str]</code> <p>Optional override for the environment. If provided (not None), it overrides the template's environment settings for ALL steps.</p> <code>None</code> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>def report(self, graph: CalculationGraph, row_templates: Optional[Dict[str, str]] = None, environment: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Generates the LaTeX report.\n\n    Args:\n        graph: The calculation graph.\n        row_templates: Optional overrides for specific row types.\n        environment: Optional override for the environment. If provided (not None), it overrides the template's environment settings for ALL steps.\n    \"\"\"\n    # 1. Resolve effective template configuration\n    current_template = self.template.copy()\n\n    # Merge row_templates if provided\n    if row_templates:\n        current_template[\"rows\"] = current_template.get(\"rows\", {}).copy()\n        current_template[\"rows\"].update(row_templates)\n\n    rows_config = current_template.get(\"rows\", {})\n    envs_config = current_template.get(\"environments\", {})\n\n    lines = []\n    current_env = None\n\n    for step in graph.steps:\n        if step.get(\"hidden\", False):\n            continue\n\n        step_type = step[\"type\"]\n\n        # Determine required environment\n        # Priority: \n        # 1. `environment` argument (if explicit override provided)\n        # 2. Template `environments` config for this type\n        # 3. Default \"align*\"\n\n        if environment is not None:\n            req_env = environment\n        else:\n            req_env = envs_config.get(step_type, \"align*\")\n\n        # Environment switching\n        if current_env != req_env:\n            if current_env is not None:\n                lines.append(f\"\\\\end{{{current_env}}}\")\n\n            if req_env is not None:\n                lines.append(f\"\\\\begin{{{req_env}}}\")\n\n            current_env = req_env\n\n        # Prepare data for template\n        data = {\n            \"symbol\": step.get(\"symbol\", \"\"),\n            \"name\": step.get(\"name\", \"\"),\n            \"desc\": step.get(\"desc\", \"\"),\n            \"value\": \"\",\n            \"expr\": \"\",\n            \"status\": \"\"\n        }\n\n        if step_type == \"param\":\n            data[\"value\"] = self._format_value(step[\"value\"], step.get(\"fmt\"))\n\n        elif step_type == \"eq\":\n            data[\"value\"] = self._format_value(step.get(\"result\"), step.get(\"fmt\"))\n            data[\"expr\"] = self._format_expr(step[\"expr\"], graph)\n\n        elif step_type == \"check\":\n            data[\"status\"] = r\"\\textbf{\\textcolor{green}{OK}}\" if step.get(\"result\") else r\"\\textbf{\\textcolor{red}{NOK}}\"\n            try:\n                local_dict = {name: sympy.Symbol(name) for name in graph.params.keys()}\n                sym_expr = sympy.sympify(step[\"expr\"], locals=local_dict, evaluate=False)\n                if not step.get(\"result\"):\n                    sym_expr = sympy.Not(sym_expr)\n                subs = {}\n                for sym in sym_expr.free_symbols:\n                    sym_name = str(sym)\n                    if sym_name in graph.params:\n                        val = graph.params[sym_name]\n                        latex_sym = graph.symbols.get(sym_name, sym_name)\n                        fmt = step.get(\"fmt\")\n                        if fmt is None:\n                            for s in graph.steps:\n                                if s.get(\"name\") == sym_name:\n                                    fmt = s.get(\"fmt\")\n                                    break\n                        val_str = self._format_value(val, fmt)\n                        # Simple substitution for logic display\n                        new_sym_latex = rf\"{{{latex_sym}}} = {val_str}\"\n                        subs[sym] = sympy.Symbol(new_sym_latex)\n                data[\"expr\"] = sympy.latex(sym_expr.subs(subs))\n            except Exception:\n                data[\"expr\"] = self._format_expr(step[\"expr\"], graph)\n\n        # Render row\n        try:\n            row_tpl = rows_config.get(step_type, \"\")\n            line = row_tpl.format(**data)\n            lines.append(line)\n        except Exception as e:\n            lines.append(f\"% Error rendering step {step.get('name')}: {e}\")\n\n    # Close final environment\n    if current_env is not None:\n        lines.append(f\"\\\\end{{{current_env}}}\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.SimpleFormBuilder","title":"<code>SimpleFormBuilder</code>","text":"<p>Facade for creating physical calculation reports, orchestrating Graph, Engine and Formatter.</p> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>class SimpleFormBuilder:\n    \"\"\"\n    Facade for creating physical calculation reports, orchestrating Graph, Engine and Formatter.\n    \"\"\"\n\n    def __init__(self, precision: int = 2, template: str = \"standard\"):\n        \"\"\"\n        Initializes the builder composition.\n\n        Attributes:\n            graph (CalculationGraph): Stores logic.\n            engine (CalculationEngine): Executes logic.\n            formatter (LaTeXFormatter): Formats output.\n        \"\"\"\n        self.graph = CalculationGraph()\n        self.engine = CalculationEngine()\n        self.formatter = LaTeXFormatter(precision=precision, template=template)\n\n    @property\n    def ureg(self):\n        return self.engine.ureg\n\n    @property\n    def params(self):\n        return self.graph.params\n\n    @property\n    def symbols(self):\n        return self.graph.symbols\n\n    @property\n    def steps(self):\n        return self.graph.steps\n\n    @property\n    def precision(self):\n        return self.formatter.precision\n\n    @precision.setter\n    def precision(self, value):\n        self.formatter.precision = value\n\n    def add_param(self, name: str, symbol: str, value: Any, desc: str = \"\", hidden: bool = False, fmt: str = None):\n        \"\"\"\n        Registers a constant parameter.\n\n        Args:\n            name (str): Unique identifier for the parameter (valid Python identifier).\n            symbol (str): LaTeX representation (e.g., \"\\\\sigma\").\n            value (int, float, pint.Quantity, np.ndarray): Numerical value or Quantity.\n            desc (str, optional): Description. Defaults to \"\".\n            hidden (bool, optional): Hide from report. Defaults to False.\n            fmt (str, optional): Format string. Defaults to None.\n        \"\"\"\n        self.graph.add_param(name, symbol, value, desc, hidden, fmt)\n\n    def add_equation(self, name: str, symbol: str, expr: str, unit: Any = None, desc: str = \"\", hidden: bool = False, fmt: str = None):\n        \"\"\"\n        Registers an equation to be calculated.\n\n        Args:\n            name (str): Unique identifier for the result.\n            symbol (str): LaTeX representation.\n            expr (str): Mathematical expression.\n            unit (Any, optional): Expected unit. Defaults to None.\n            desc (str, optional): Description. Defaults to \"\".\n            hidden (bool, optional): Hide from report. Defaults to False.\n            fmt (str, optional): Format string. Defaults to None.\n        \"\"\"\n        self.graph.add_equation(name, symbol, expr, unit, desc, hidden, fmt)\n        # Compatibility: Pre-compilation check could happen here if we wanted to enforce fail-fast nature of original code.\n        # But we delegate actual compilation to evaluate() or explicit lambdify.\n        # To strictly better separate concerns, validation is done in Graph (security), logic in Engine.\n\n    def add_check(self, expr: str, desc: str, name: str = \"Check\", fmt: str = None):\n        \"\"\"\n        Adds a validation step.\n\n        Args:\n            expr (str): Boolean expression.\n            desc (str): Description.\n            name (str, optional): Identifier. Defaults to \"Check\".\n            fmt (str, optional): Format string. Defaults to None.\n        \"\"\"\n        self.graph.add_check(expr, desc, name, fmt)\n\n    def evaluate(self):\n        \"\"\"\n        Executes all registered calculations sequentially.\n        \"\"\"\n        self.engine.evaluate(self.graph)\n\n    def lambdify_equation(self, name: str) -&gt; Any:\n        \"\"\"\n        Creates a function from the specified equation compatible with pandas.DataFrame.assign.\n\n        Mechanisms:\n        1. **Variable Resolution Priority**:\n           - **DataFrame/Input Dict**: Variables present in the input `df` (columns or keys) are used first.\n           - **Parameters**: If a variable is not in `df` but exists in `SimpleFormBuilder.params`, it is treated as a constant.\n           - **Error**: If missing in both, a `KeyError` is raised.\n\n        2. **Unit Injection**:\n           - If a variable comes from `df` but also exists in `params` as a `pint.Quantity`, the corresponding unit is automatically injected (multiplied) into the values from `df`. This ensures unit consistency within the expression.\n\n        3. **Unit Output**:\n           - If the equation has a target `unit` defined, the result is converted to that unit before being returned.\n\n        Args:\n            name (str): The name of the equation.\n\n        Returns:\n            Callable: compiled function.\n        \"\"\"\n        return self.engine.lambdify_equation(self.graph, name)\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"\n        Allows dictionary-style access to parameters and results.\n        \"\"\"\n        return self.graph.params[key]\n\n    def report(self, row_templates: Optional[Dict[str, str]] = None, environment: str = None) -&gt; str:\n        \"\"\"\n        Generates the LaTeX report.\n\n        Args:\n            row_templates (Dict[str, str], optional): Custom templates.\n            environment (str, optional): LaTeX environment override. \n                                         If None (default), uses the template's defined environments.\n                                         If provided, forces all steps to this environment.\n\n        Returns:\n            str: The generated LaTeX code.\n        \"\"\"\n        return self.formatter.report(self.graph, row_templates, environment)\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.SimpleFormBuilder.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Allows dictionary-style access to parameters and results.</p> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n    \"\"\"\n    Allows dictionary-style access to parameters and results.\n    \"\"\"\n    return self.graph.params[key]\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.SimpleFormBuilder.__init__","title":"<code>__init__(precision=2, template='standard')</code>","text":"<p>Initializes the builder composition.</p> <p>Attributes:</p> Name Type Description <code>graph</code> <code>CalculationGraph</code> <p>Stores logic.</p> <code>engine</code> <code>CalculationEngine</code> <p>Executes logic.</p> <code>formatter</code> <code>LaTeXFormatter</code> <p>Formats output.</p> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>def __init__(self, precision: int = 2, template: str = \"standard\"):\n    \"\"\"\n    Initializes the builder composition.\n\n    Attributes:\n        graph (CalculationGraph): Stores logic.\n        engine (CalculationEngine): Executes logic.\n        formatter (LaTeXFormatter): Formats output.\n    \"\"\"\n    self.graph = CalculationGraph()\n    self.engine = CalculationEngine()\n    self.formatter = LaTeXFormatter(precision=precision, template=template)\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.SimpleFormBuilder.add_check","title":"<code>add_check(expr, desc, name='Check', fmt=None)</code>","text":"<p>Adds a validation step.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>Boolean expression.</p> required <code>desc</code> <code>str</code> <p>Description.</p> required <code>name</code> <code>str</code> <p>Identifier. Defaults to \"Check\".</p> <code>'Check'</code> <code>fmt</code> <code>str</code> <p>Format string. Defaults to None.</p> <code>None</code> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>def add_check(self, expr: str, desc: str, name: str = \"Check\", fmt: str = None):\n    \"\"\"\n    Adds a validation step.\n\n    Args:\n        expr (str): Boolean expression.\n        desc (str): Description.\n        name (str, optional): Identifier. Defaults to \"Check\".\n        fmt (str, optional): Format string. Defaults to None.\n    \"\"\"\n    self.graph.add_check(expr, desc, name, fmt)\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.SimpleFormBuilder.add_equation","title":"<code>add_equation(name, symbol, expr, unit=None, desc='', hidden=False, fmt=None)</code>","text":"<p>Registers an equation to be calculated.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the result.</p> required <code>symbol</code> <code>str</code> <p>LaTeX representation.</p> required <code>expr</code> <code>str</code> <p>Mathematical expression.</p> required <code>unit</code> <code>Any</code> <p>Expected unit. Defaults to None.</p> <code>None</code> <code>desc</code> <code>str</code> <p>Description. Defaults to \"\".</p> <code>''</code> <code>hidden</code> <code>bool</code> <p>Hide from report. Defaults to False.</p> <code>False</code> <code>fmt</code> <code>str</code> <p>Format string. Defaults to None.</p> <code>None</code> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>def add_equation(self, name: str, symbol: str, expr: str, unit: Any = None, desc: str = \"\", hidden: bool = False, fmt: str = None):\n    \"\"\"\n    Registers an equation to be calculated.\n\n    Args:\n        name (str): Unique identifier for the result.\n        symbol (str): LaTeX representation.\n        expr (str): Mathematical expression.\n        unit (Any, optional): Expected unit. Defaults to None.\n        desc (str, optional): Description. Defaults to \"\".\n        hidden (bool, optional): Hide from report. Defaults to False.\n        fmt (str, optional): Format string. Defaults to None.\n    \"\"\"\n    self.graph.add_equation(name, symbol, expr, unit, desc, hidden, fmt)\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.SimpleFormBuilder.add_param","title":"<code>add_param(name, symbol, value, desc='', hidden=False, fmt=None)</code>","text":"<p>Registers a constant parameter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the parameter (valid Python identifier).</p> required <code>symbol</code> <code>str</code> <p>LaTeX representation (e.g., \"\\sigma\").</p> required <code>value</code> <code>(int, float, Quantity, ndarray)</code> <p>Numerical value or Quantity.</p> required <code>desc</code> <code>str</code> <p>Description. Defaults to \"\".</p> <code>''</code> <code>hidden</code> <code>bool</code> <p>Hide from report. Defaults to False.</p> <code>False</code> <code>fmt</code> <code>str</code> <p>Format string. Defaults to None.</p> <code>None</code> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>def add_param(self, name: str, symbol: str, value: Any, desc: str = \"\", hidden: bool = False, fmt: str = None):\n    \"\"\"\n    Registers a constant parameter.\n\n    Args:\n        name (str): Unique identifier for the parameter (valid Python identifier).\n        symbol (str): LaTeX representation (e.g., \"\\\\sigma\").\n        value (int, float, pint.Quantity, np.ndarray): Numerical value or Quantity.\n        desc (str, optional): Description. Defaults to \"\".\n        hidden (bool, optional): Hide from report. Defaults to False.\n        fmt (str, optional): Format string. Defaults to None.\n    \"\"\"\n    self.graph.add_param(name, symbol, value, desc, hidden, fmt)\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.SimpleFormBuilder.evaluate","title":"<code>evaluate()</code>","text":"<p>Executes all registered calculations sequentially.</p> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>def evaluate(self):\n    \"\"\"\n    Executes all registered calculations sequentially.\n    \"\"\"\n    self.engine.evaluate(self.graph)\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.SimpleFormBuilder.lambdify_equation","title":"<code>lambdify_equation(name)</code>","text":"<p>Creates a function from the specified equation compatible with pandas.DataFrame.assign.</p> <p>Mechanisms: 1. Variable Resolution Priority:    - DataFrame/Input Dict: Variables present in the input <code>df</code> (columns or keys) are used first.    - Parameters: If a variable is not in <code>df</code> but exists in <code>SimpleFormBuilder.params</code>, it is treated as a constant.    - Error: If missing in both, a <code>KeyError</code> is raised.</p> <ol> <li>Unit Injection:</li> <li> <p>If a variable comes from <code>df</code> but also exists in <code>params</code> as a <code>pint.Quantity</code>, the corresponding unit is automatically injected (multiplied) into the values from <code>df</code>. This ensures unit consistency within the expression.</p> </li> <li> <p>Unit Output:</p> </li> <li>If the equation has a target <code>unit</code> defined, the result is converted to that unit before being returned.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the equation.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Any</code> <p>compiled function.</p> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>def lambdify_equation(self, name: str) -&gt; Any:\n    \"\"\"\n    Creates a function from the specified equation compatible with pandas.DataFrame.assign.\n\n    Mechanisms:\n    1. **Variable Resolution Priority**:\n       - **DataFrame/Input Dict**: Variables present in the input `df` (columns or keys) are used first.\n       - **Parameters**: If a variable is not in `df` but exists in `SimpleFormBuilder.params`, it is treated as a constant.\n       - **Error**: If missing in both, a `KeyError` is raised.\n\n    2. **Unit Injection**:\n       - If a variable comes from `df` but also exists in `params` as a `pint.Quantity`, the corresponding unit is automatically injected (multiplied) into the values from `df`. This ensures unit consistency within the expression.\n\n    3. **Unit Output**:\n       - If the equation has a target `unit` defined, the result is converted to that unit before being returned.\n\n    Args:\n        name (str): The name of the equation.\n\n    Returns:\n        Callable: compiled function.\n    \"\"\"\n    return self.engine.lambdify_equation(self.graph, name)\n</code></pre>"},{"location":"reference/#simpleformbuilder.builder.SimpleFormBuilder.report","title":"<code>report(row_templates=None, environment=None)</code>","text":"<p>Generates the LaTeX report.</p> <p>Parameters:</p> Name Type Description Default <code>row_templates</code> <code>Dict[str, str]</code> <p>Custom templates.</p> <code>None</code> <code>environment</code> <code>str</code> <p>LaTeX environment override.                           If None (default), uses the template's defined environments.                          If provided, forces all steps to this environment.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated LaTeX code.</p> Source code in <code>simpleformbuilder\\builder.py</code> <pre><code>def report(self, row_templates: Optional[Dict[str, str]] = None, environment: str = None) -&gt; str:\n    \"\"\"\n    Generates the LaTeX report.\n\n    Args:\n        row_templates (Dict[str, str], optional): Custom templates.\n        environment (str, optional): LaTeX environment override. \n                                     If None (default), uses the template's defined environments.\n                                     If provided, forces all steps to this environment.\n\n    Returns:\n        str: The generated LaTeX code.\n    \"\"\"\n    return self.formatter.report(self.graph, row_templates, environment)\n</code></pre>"}]}